# fbe7b4644c8e0a8231c8b815b3f2ff6af795669954f292a7077dd33ebc6f6c09 Elan Beta 1 valid

# This version does not use expressions in copy...with. It is compiling, but not running
main
  var game set to new Game(firstRandom())
  while game.isOn
    var gr set to game.graphics
    call gr.draw()
    call pause(150)
    set game to clockTick(game, gr.getKeystroke())
  end while
  print "Game Over! Score: {score(game)}"
end main

function clockTick(g as Game, k as String) return Game
  let g2 be copy g with key to k
  let g3 be moveSnake(g2)
  let body be g3.body
  let newBody be body.getRange(1, body.length() - 1)
  let g4 be if g3.head is g3.apple then moveApple(g3) else copy g3 with body to newBody
  return updateGraphics(g4)
end function

function updateGraphics(g as Game) return Game
  let gr be g.graphics
  let apple be g.apple
  let gr1 be gr.putBackground(apple.x, apple.y, red)
  let g2 be copy g with graphics to gr1
  let gr2 be g2.graphics
  let head be g2.head
  let gr2plus be gr2.putBackground(head.x, head.y, green)
  let g3 be copy g2 with graphics to gr2plus
  let body be g3.body
  let tail be body.get(0)
  let tailColour be if tail is g3.priorTail then green else white
  let gr3 be g3.graphics
  let gr4 be gr3.putBackground(tail.x, tail.y, tailColour)
  return copy g3 with graphics to gr4
end function

function moveApple(g as Game) return Game
  let random be g.rnd
  let x be random.valueInt(0, 39)
  let rnd2 be random.next()
  let y be rnd2.valueInt(0, 29)
  let newApple be new Square(x, y)
  let rndNext be rnd2.next()
  let g2 be copy g with apple to newApple, rnd to rndnext
  return if bodyOverlaps(g2, g2.apple) then moveApple(g2) else g2
end function

function score(g as Game) return Int
  let body be g.body
  return body.length() - 1
end function

function moveSnake(g as Game) return Game
  let head be g.head
  let newX be if g.key is "a" then head.x - 1 else if g.key is "d" then head.x + 1 else head.x
  let newY be if g.key is "w" then head.y - 1 else if g.key is "s" then head.y + 1 else head.y
  let gbody be g.body
  let currentTail be gbody.get(0)
  let newHead be new Square(newX, newY)
  let newBody be gbody + g.head
  return copy g with priorTail to currentTail, body to newBody, head to newHead
end function

function gameOver(g as Game) return Boolean
  return bodyOverlaps(g, g.head) or headIsAtEdge(g)
end function

function headIsAtEdge(g as Game) return Boolean
  let head be g.head
  return (head.x is -1) or (head.y is -1) or (head.x is 40) or (head.y is 30)
end function

function bodyOverlaps(g as Game, target as Square) return Boolean
  let body be g.body
  return body.any(lambda s as Square => s is target)
end function

immutable class Game
  constructor(rnd as Random)
    set property.graphics to new Graphics()
    var tail set to new Square(20, 15)
    set property.head to new Square(21, 15)
    set property.priorTail to tail
    set property.body to {tail, head}
    set property.apple to new Square(20, 10)
    set property.isOn to true
    set property.rnd to rnd
  end constructor

  property head as Square

  property body as {Square}

  property priorTail as Square

  property apple as Square

  property isOn as Boolean

  property rnd as Random

  property graphics as Graphics

  property key as String

end class

immutable class Square
  constructor(x as Int, y as Int)
    set property.x to x
    set property.y to y
  end constructor

  property x as Int

  property y as Int

end class

constant green set to 0x00ff00

constant red set to 0xff0000

constant white set to 0xffffff
