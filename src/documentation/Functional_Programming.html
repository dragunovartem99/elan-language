<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../styles/colourScheme.css" rel="stylesheet" />
<link href="../styles/documentation.css" rel="stylesheet" />
<link href="../styles/elanStyle.css" rel="stylesheet" />
<title>Elan Functional Programming</title>
</head>
<body>
<p>Elan is a 'multi-paradigm' programming language. It supports
<ul>
    <li>Procedural programming</li>
    <li>Object-oriented programming</li>
    <li>Functional programming</li>
</ul>
and it is a very good way to learn all three of them. Elan lays a very strong foundation
that will make it easier for you to transition later on to more languages that are specialised
towards one of the three programming languages such as Java, C#, or TypeScript for object-oriented programming; 
or Haskell, OCaml, or F#, for functional programming. Other popular multi-paradigm languages such as Python, 
VB, C#, and Java do not lay as good a foundation. 

<p>Functional programming means constructing programs from pure function. A pure function: 

    <ul>
        <li>returns a value that is derived solely and deterministically from the values passed to it as parameters</li>
        <li>may call other pure functions but may not depend upon any information other than was passed to it as parameters</li>
        <li>may not generate any 'side effects'. A side effect is anything information, or change to the state of the system,
             that could be observed by code ouside the function <i>other than</i> the value returned by the function.</li>
    </ul>

<p>The reason for these constraints is that pure functions can be combined to form a program where the results are entirely predictable
    and guaranteed. This, surprisingly perhaps, is not the case with impure functions, because external dependencies
and side-effects can result in unexpected interference between the combined functions. </p>

<p>However, as Simon Peyton Jones, one of the leading exponents of functional programming and lead developer of Haskell has said,</p>

<p><i>'The problem is that the whole point of systems is to produce side-effects'</i>, meaning that if a program doesn't <i>at minimum</i> produce
any output - whether displayed on a screen, stored in a file, transmitted over a network, 
or driving an actuator in a mechanical device A-level. Then it isn't doing anything useful!</p>

<p>Pure functional programming languages such as Haskell enforce that <i>all</i> functions are pure - even functions that are responsible
for input/output which sounds like a contradiction. But the way that that conundrum is resolved is one of the reasons why learning
to write whole applications in a pure functional language is difficult.</p>

<p>If you want to learn functional programming in a multi-paradigm language such as Python, VB, or C#, say, then you have
    to split your program into the pure parts that cover the core data transformations, and the 'impure' parts that handle.
    The problem with that approach, is that those languages cannot enforce that separation, and it is all to easy to 
    find side-effects and dependencies creeping into your supposedly-pure core functionality.</p>

<p>Elan is almost unique amongst</p>

</body>
</html>
