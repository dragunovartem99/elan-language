# ef52c95fd82d33949c802d080ba90a7d614635ccce3d53fd7f58a442ca997d88 Elan v0.1 valid

main
  var cm set to new CharMap()
  var g set to exampleCells
  while true
    call drawGrid(cm, g)
    set g to nextGeneration(g)
  end while
end main

procedure drawGrid(cm CharMap, grid List<of Bool>)
  # should be re-done using buffered char map to reduce flickering.
  for row from 0 to 19 step 1
    for col from 0 to 19 step 1
      var cell set to grid[col * 20 + row]
      var colour set to if cell then Colour.white else Colour.black
      call cm.putBlockWithColour((col * 2), row, colour)
      call cm.putBlockWithColour((col * 2 + 1), row, colour)
      # because square block is 2 chars wide
    end for
  end for
end procedure

function north(c Int) returning Int
  return if c > 19 then c - 20 else   c + 380
end function

function south(c Int) returning Int
  return if c < 380 then c + 20 else c - 380
end function

function east(c Int) returning Int
  return if c mod 20 < 19 then c + 1 else c - 19
end function

function west(c Int) returning Int
  return if c mod 20 > 0 then c - 1 else c + 1
end function

function northEast(c Int) returning Int
  return north(east(c))
end function

function southEast(c Int) returning Int
  return south(east(c))
end function

function northWest(c Int) returning Int
  return north(west(c))
end function

function southWest(c Int) returning Int
  return south(west(c))
end function

function neighbourCells(c Int) returning List<of Int>
  return {northWest(c), north(c), northEast(c), west(c), east(c), southWest(c), south(c), southEast(c)}
end function

function liveNeighbours(cells List<of Bool>, c Int) returning Int
  return neighbourCells(c).filter(lambda i -> cells[i]).count()
end function

function willLive(currentlyAlive Bool, liveNeighbours Int) returning Bool
  return if currentlyAlive then liveNeighbours > 1 and liveNeighbours < 4 else liveNeighbours is 3
end function

function nextCellValue(cells List<of Bool>, c Int) returning Bool
  return willLive(cells[c], liveNeighbours(cells, c))
end function

function nextGeneration(cells List<of Bool>) returning List<of Bool>
  return integers(0, cells.length()-1).map(lambda n -> nextCellValue(cells, n)).asList()
end function

constant exampleCells set to {false, true, false, true, false, false, true, true, true, false, false, true, true, false, true, true, false, false, true, true, true, true, true, true, false, false, true, false, true, true, true, false, true, true, true, true, false, true, false, true, false, false, true, true, false, false, false, false, true, false, false, false, true, false, false, false, true, false, false, false, true, false, false, true, false, false, true, false, false, true, true, false, false, false, true, true, false, false, true, true, false, true, true, true, true, false, false, false, false, false, false, false, false, true, true, false, true, false, false, true, true, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, true, false, false, true, true, false, true, false, true, true, false, false, false, false, false, true, false, false, true, false, true, false, true, false, true, false, true, false, false, true, false, true, false, true, false, false, true, false, false, true, true, false, true, false, false, true, false, true, false, true, true, false, false, false, false, true, false, false, true, false, false, false, false, true, false, false, false, true, false, true, false, true, false, false, false, false, false, true, true, false, true, true, false, false, false, false, false, true, false, false, true, true, true, false, false, false, true, false, true, false, false, true, true, false, true, false, true, false, true, false, false, true, false, true, false, true, false, true, false, false, false, true, false, false, false, true, false, true, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false, true, false, true, false, false, true, false, true, false, true, false, false, false, false, false, true, false, true, false, false, false, false, true, true, false, false, true, true, false, true, true, false, true, true, false, true, false, false, true, false, true, false, false, true, false, true, true, false, false, false, false, false, true, true, false, false, false, true, true, true, false, false, false, true, true, false, true, true, true, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, true, false, true, false, false, true, true, false, false, true, true, true, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, true, false, false, false, true, false}
