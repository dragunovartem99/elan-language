# 51775cc8782624fc908798c11ccabc535256cba4a4ac9cd066c79dace4d2bf02 Elan v0.1 valid

function isYellow(attempt as String, target as String, n as Int) return Bool
  return target.contains(attempt[n])
end function

function setAttemptIfYellow(attempt as String, target as String, n as Int) return String
  return if attempt[n] is '*' then attempt else if attempt.isYellow(target, n) then attempt.setChar(n, '+') else attempt.setChar(n, '_')
end function

function setTargetIfYellow(attempt as String, target as String, n as Int) return String
  return if attempt.isAlreadyMarkedGreen(n) then target else if attempt.isYellow(target, n) then target.setChar(target.indexOf(attempt[n]), '.') else target
end function

constant allPossibleAnswers set to ["ABACK","ABASE","ABATE","ABBEY","ABBOT","ABHOR","ABIDE","ABLED","ABODE","ABORT","ABOUT","ABOVE"]

constant validWords set to ["ABACK","ABASE","ABATE","ABBEY","ABBOT","ABHOR","ABIDE","ABLED","ABODE","ABORT","ABOUT","ABOVE"]

main
  var possible set to validWords
  var marking set to ""
  var attempt set to "RAISE"
  while marking is not "*****"
    print attempt
    input marking
    set possible to possibleAnswersAfterAttempt(possible, attempt, marking)
    set attempt to bestAttempt(possible.asList(), validWords)
  end while
end main

function isGreen(attempt as String, target as String, n as Int) return Bool
  return target[n] is attempt[n]
end function

function setChar(word as String, n as Int, newChar as Char) return String
  return word[..n] + newChar + word[n+1..]
end function

function setAttemptIfGreen(attempt as String, target as String, n as Int) return String
  return if  attempt.isGreen(target, n) then attempt.setChar(n, '*')  else attempt
end function

function setTargetIfGreen(attempt as String, target as String, n as Int) return String
  return if  attempt.isGreen(target, n) then target.setChar(n, '.') else target
end function

function isAlreadyMarkedGreen(attempt as String, n as Int) return Bool
  return attempt[n] is '*'
end function

constant letterPositions set to [0,1,2,3,4]

function evaluateGreens(attempt as String, target as String) return (String, String)
  return letterPositions.reduce((attempt, target), lambda a as (String, String), x as Int return (setAttemptIfGreen(a.attempt, a.target, x), setTargetIfGreen(a.attempt, a.target, x)))
end function

function evaluateYellows(attempt as String, target as String) return (String, String)
  return letterPositions.reduce((attempt, target),lambda a as (String, String), x as Int return (setAttemptIfYellow(a.attempt, a.target, x), setTargetIfYellow(a.attempt, a.target, x)))
end function

function markAttempt(attempt as String, target as String) return String
  var (attemptAfterGreens, targetAfterGreens) set to evaluateGreens(attempt, target)
  var markedAttempt set to attemptAfterGreens.evaluateYellows(targetAfterGreens)
  return markedAttempt.first()
end function

function possibleAnswersAfterAttempt(prior as Iter<of String>, attempt as String, mark as String) return Iter<of String>
  return prior.filter(lambda w as String return markAttempt(attempt, w) is mark)
end function

function wordCountRemainingAfterAttempt(possibleAnswers as Iter<of String>, attempt as String) return WordCount
  var groups set to possibleAnswers.groupBy(lambda w as String return markAttempt(attempt, w))
  var largest set to groups.maxBy(size)
  var members set to largest.members
  var count set to members.count()
  return new WordCount(attempt, count)
end function

function size(g as Group<of String>) return Int
  var members set to g.members
  return members.count
end function

function allRemainingWordCounts(possAnswers as List<of String>, possAttempts as Iter<of String>) return Iter<of WordCount>
  var parallel set to possAttempts.asParallel()
  return parallel.map(lambda w as String return wordCountRemainingAfterAttempt(possAnswers, w))
end function

function betterOf(wc1 as WordCount, wc2 as WordCount, possAnswers as Iter<of String>) return WordCount
  var isBetter set to wc2.count < wc1.count
  var isEqualAndPossAnswer set to wc2.count is wc1.count and possAnswers.contains(wc2.word)
  return if isBetter or isEqualAndPossAnswer then wc2 else wc1
end function

function bestAttempt(possAnswers as List<of String>,possAttempts as List<of String>) return String
  var wordCounts set to allRemainingWordCounts(possAnswers, possAttempts)
  var best set to wordCounts.reduce(wordCounts.head(),lambda bestSoFar as String, newWord as String return betterOf(bestSoFar, newWord, possAnswers))
  return best.word
end function

immutable class WordCount
  constructor(word as String, count as Int)
    set property.word to word
    set property.count to count
  end constructor

  property word as String

  property count as Int

end class
